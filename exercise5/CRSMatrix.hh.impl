template < typename T >
bool CRSMatrix<T>::entryExists( size_type i, size_type j ) const {
  // If the last row is considerred, indices.begin() + (i+1) * colCount may be != indices.end(), thus special case
  // search in the corresponding subrange in indices if the entry "j" exists or not (no binary search as in the range may be zeros after the greatest col-index with an entry)
  auto const result = std::find( indices.begin() + i*maxNonzeroPerRow, indices.begin() + i*maxNonzeroPerRow + offset[i], j );
  // std::find returns result = final iterator if the value is not found
	return result != indices.begin() + i*maxNonzeroPerRow + offset[i];
}
template < typename T >
typename CRSMatrix<T>::size_type CRSMatrix<T>::findValuesIndex( CRSMatrix::size_type i, CRSMatrix::size_type j ) const {
	assert( entryExists(i,j) );
	
  // ternary ? -> similar to entryExists
  // std::find returns an iterator
	auto const valueIterator = std::find( indices.begin() + i*maxNonzeroPerRow, indices.begin() + i*maxNonzeroPerRow + offset[i], j );
	return std::distance( indices.begin(), valueIterator );
}

template < typename T >
void CRSMatrix<T>::insertEntry( CRSMatrix::size_type i, CRSMatrix::size_type j, CRSMatrix::value_type value ) {
  using size_type = CRSMatrix::size_type;
  
	assert( ! entryExists(i,j) );
	
  // ternary ? -> similar to entryExists
	auto const indicesInsertPos = std::lower_bound( indices.begin() + i*maxNonzeroPerRow, indices.begin() + i*maxNonzeroPerRow + offset[i], j );
  size_type const k = std::distance( indices.begin(), indicesInsertPos );
  
  // use the meaning of maxNonZeroEntriesPerRow
  //  indices = [ 0 ... i*maxNonZeroEntriesPerRow i*maxNonZeroEntriesPerRow+1 i*maxNonZeroEntriesPerRow+2 ... i*maxNonZeroEntriesPerRow+maxNonZeroEntriesPerRow-1 (i+1)*maxNonZeroEntriesPerRow ... ]
  //                                                                              |                             |
  //                                                                              +-- e.g. k                    +---- zero, i.e. can be overwritten, as the last entry in the row, and (i,j) does not exist
  // move all indices and values by 1 from k to (i+1)*maxNonZeroEntriesPerRow-1
  for( size_type l = (i+1) * maxNonzeroPerRow - 1; l > k; l-- ) {
    values[l] = values[l-1];
    indices[l] = indices[l-1];
  }
  //update with new value
  values[k] = value;
  indices[k] = j;
	
	//update offset, starting at i+1
	offset[i]++;
}

template < typename T >
void CRSMatrix<T>::add( CRSMatrix::size_type i, CRSMatrix::size_type j, CRSMatrix::value_type value) {
	if( entryExists( i,j ) ) {
		values[ findValuesIndex(i,j) ] += value;
	}
	else {
		insertEntry( i, j, value );
	}
}

template < typename T >
void CRSMatrix<T>::set( CRSMatrix::size_type i, CRSMatrix::size_type j, CRSMatrix::value_type value) {
	if( entryExists( i,j ) ) {
		values[ findValuesIndex(i,j) ] = value;
	}
	else {
		insertEntry( i, j, value );
	}
}

template < typename T >
void CRSMatrix<T>::compress() {
  using size_type = CRSMatrix::size_type;
  
  //dense values & indices - copy all nonzero into a contiguous block.
  size_type j = 0;
  for( size_type k = 0; k < offset.size(); k++ ) {
    for( size_type i = 0; i < offset[k]; i++ ) {
      values[j] = values[k*maxNonzeroPerRow+i];
      indices[j++] = indices[k*maxNonzeroPerRow+i];
    }
  }
  //put offset into new format
  const auto nonZeroElements = std::accumulate( offset.begin(), offset.end(), size_type{0} );
  offset.back() = nonZeroElements - offset.back();
  for( int i=rowCount - 2; i >= 0; i-- ) {
    offset[i] = offset[i+1] - offset[i];
  }
  
  //remove the trailing elements
  values.resize(nonZeroElements);
  indices.resize(nonZeroElements);
}

template < typename T >
void CRSMatrix<T>::mv( Vector const& x, Vector& y ) const {
  using size_type = CRSMatrix<T>::size_type;
  
  //size constraint
	assert( x.size() == y.size() && colCount == x.size() );
  //compressed only
  // potential bug: compressed matrix
  assert( indices.size() < rowCount * maxNonzeroPerRow );
	
	//initialize y with 0
	y.fill( CRSMatrix::value_type{0} );
	
	//store current offset-index to access the correct row
	size_type i = 0;
	for( size_type k = 0; k < values.size(); k++ ) {
		//update the row index
		if( offset[i+1] == k )
			i++;
		
		y[ i ] += values[k] * x[ indices[k] ];
	}
}
